import { Callout, Steps, Tabs } from "nextra/components";

# Make Payments

Lucid Evolution provides several methods for making payments, each with specific use cases

---

## Simple ADA payment

For straightforward payments to a public key or native script address, `pay.ToAddress` is your go-to method.

```typescript
const tx = await lucid
  .newTx()
  .pay.ToAddress("addr_test...", { lovelace: 5000000n })
  .complete();

const signedTx = await tx.sign.withWallet().complete();
const txHash = await signedTx.submit();
```

<Callout type="info" emoji="ℹ️">
  __Evolution-Notes:__ Change from `payToAddress` -> `pay.ToAddress`
</Callout>

---

### Multiple Recipients

Need to pay multiple addresses?

You can chain multiple `pay.ToAddress` calls to pay to multiple recipients. Each `pay.ToAddress` call creates a new UTxO, also for the same addresses.
Lucid Evolution takes the order of outputs into account
```typescript
const tx = await lucid
  .newTx()
  .pay.ToAddress("addr_testa...", { lovelace: 5000000n })
  .pay.ToAddress("addr_testb...", { lovelace: 5000000n })
  .pay.ToAddress("addr_testc...", { lovelace: 5000000n })
  .complete();

const signedTx = await tx.sign.withWallet().complete();
const txHash = await signedTx.submit();
```

---

### Payment with Cardano Native Tokens (CNT)

Sending CNTs? Lucid Evolution automatically adds the minimum ADA requirement for you.

```typescript
const policyId = "00...";
const assetName = "MyToken";

const tx = await lucid
  .newTx()
  .pay.ToAddress("addr_test...", { [policyId + fromText(assetName)]: 10n })
  .complete();

const signedTx = await tx.sign.withWallet().complete();
const txHash = await signedTx.submit();
```

---

### Payment with Metadata

Attach metadata to your ADA payments for additional context

```typescript
const tx = await lucid
  .newTx()
  .pay.ToAddress("addr_test...", { lovelace: 5000000n })
  .attachMetadata(1, { msg: "Hello from Anastasia Labs" })
  .complete();

const signedTx = await tx.sign.withWallet().complete();
const txHash = await signedTx.submit();
```

---

## Payment with Datum / Script Reference

For more complex scenarios, `pay.ToAddressWithData` allows you to include a datum or script reference. 
 Lucid Evolution then implicitly adds the minimum ADA requirement for datums.

<Tabs items={['Datum', 'Script Reference']}>
  <Tabs.Tab>
The datum is attached to the witness set, with its hash stored in the UTxO.

```typescript
const tx = await lucid
  .newTx()
  .pay.ToAddressWithData(
    "addr_test...",
    { kind: "hash", value: Data.to("31313131") },
    { lovelace: 5000000n }
  )
  .complete();

const signedTx = await tx.sign.withWallet().complete();
const txHash = await signedTx.submit();
```

  </Tabs.Tab>
  <Tabs.Tab>
To inline the datum directly in the UTxO use

```typescript
{ kind: "inline", value: Data.to("31313131") }
```

  </Tabs.Tab>
</Tabs>




<Callout type="info" emoji="ℹ️">
__Evolution-Notes:__ `payToAddressWithData`-> `pay.ToAddressWithData`

The `pay.ToAddressWithData` method accepts the following parameters:

- Address
- OutputDatum (can be of type "hash", "inline", or "asHash")
- Assets (optional)
- Script reference (optional)
</Callout>

---

## Payment to a Plutus script address

Use `pay.ToContract` for payments to a Plutus script address. This method ensures that a datum is provided.

```typescript
const tx = await lucid
  .newTx()
  .pay.ToContract(
    "addr_test...",
    { kind: "inline", value: Data.to("31313131") },
    { lovelace: 5000000n }
  )
  .complete();

const signedTx = await tx.sign.withWallet().complete();
const txHash = await signedTx.submit();
```
