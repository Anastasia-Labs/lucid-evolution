import { Callout, Steps, Tabs } from "nextra/components";

# Making Payments

Lucid Evolution provides several methods for making payments on the Cardano blockchain, each designed for specific use cases.

## Payment Methods

<Tabs items={['Basic Payments', 'Advanced Payments', 'Script Payments']}>
  <Tabs.Tab>
    ### Simple ADA Payment

    For straightforward payments to a public key or native script address:

    ```typescript
    const tx = await lucid
      .newTx()
      .pay.ToAddress("addr_test...", { lovelace: 5000000n })
      .complete();

    const signedTx = await tx.sign.withWallet().complete();
    const txHash = await signedTx.submit();
    ```

    ### Multiple Recipients

    Chain multiple `pay.ToAddress` calls to pay multiple recipients:

    ```typescript
    const tx = await lucid
      .newTx()
      .pay.ToAddress("addr_testa...", { lovelace: 5000000n })
      .pay.ToAddress("addr_testb...", { lovelace: 5000000n })
      .pay.ToAddress("addr_testc...", { lovelace: 5000000n })
      .complete();

    const signedTx = await tx.sign.withWallet().complete();
    const txHash = await signedTx.submit();
    ```

    <Callout type="info">
      Each `pay.ToAddress` call creates a new UTxO, even for the same address. Lucid
      Evolution considers the order of outputs.
    </Callout>

    ### Native Tokens

    Lucid Evolution automatically adds the minimum ADA requirement for payments with Cardano Native Tokens (CNTs):

    ```typescript
    const policyId = "00...";
    const assetName = "MyToken";

    const tx = await lucid
      .newTx()
      .pay.ToAddress("addr_test...", { [policyId + fromText(assetName)]: 10n })
      .complete();

    const signedTx = await tx.sign.withWallet().complete();
    const txHash = await signedTx.submit();
    ```

  </Tabs.Tab>
  
  <Tabs.Tab>
    ### With Metadata

    Attach metadata to your ADA payments:

    ```typescript
    const tx = await lucid
      .newTx()
      .pay.ToAddress("addr_test...", { lovelace: 5000000n })
      .attachMetadata(1, { msg: "Hello from Anastasia Labs" })
      .complete();

    const signedTx = await tx.sign.withWallet().complete();
    const txHash = await signedTx.submit();
    ```

    ### With Datums

    For more complex scenarios, `pay.ToAddressWithData` allows you to include a datum:

    <Tabs items={['Hash Datum', 'Inline Datum']}>
      <Tabs.Tab>
        ```typescript
        // As hash - datum is attached to the witness set, with its hash stored in the UTxO
        const tx = await lucid
          .newTx()
          .pay.ToAddressWithData(
            "addr_test...",
            { kind: "hash", value: Data.to("31313131") },
            { lovelace: 5000000n }
          )
          .complete();
        ```
      </Tabs.Tab>
      <Tabs.Tab>
        ```typescript
        // As inline - datum stored directly in UTxO
        const tx = await lucid
          .newTx()
          .pay.ToAddressWithData(
            "addr_test...",
            { kind: "inline", value: Data.to("31313131") },
            { lovelace: 5000000n }
          )
          .complete();
        ```
      </Tabs.Tab>
    </Tabs>

  </Tabs.Tab>
  
  <Tabs.Tab>
    ### Reference Scripts

    Reference scripts allow you to deploy a validator once and reference it in future transactions, reducing costs.

    <Tabs items={['Deploy Reference Script', 'Use Reference Script']}>
      <Tabs.Tab>
        ```typescript
        const deployRefScriptTx = await lucid
          .newTx()
          .pay.ToAddressWithData(
            scriptAddress,
            { kind: "inline", value: datum },
            { lovelace: 5_000_000n },
            referenceScript // The script to be stored as a reference
          )
          .complete();
        ```
      </Tabs.Tab>
      <Tabs.Tab>
        ```typescript
        const allUTxOs = await lucid.utxosAt(scriptAddress);
        const refScriptUTxO = allUTxOs.filter((utxo) => utxo.scriptRef)[0];

        const useRefScriptTx = await lucid
          .newTx()
          .collectFrom([utxoToSpend], redeemer)
          .readFrom([refScriptUTxO]) // Reference the script UTxO
          .complete();
        ```
      </Tabs.Tab>
    </Tabs>

    <Callout type="info">
      Reference scripts are stored on-chain in a UTxO and can be "referenced" by
      other transactions, reducing transaction sizes and costs. This way the script
      only needs to be stored once and can be reused by multiple transactions.
    </Callout>

    ### Plutus Script Payments

    Use `pay.ToContract` for payments to a Plutus script address. This method ensures that a datum is provided:

    ```typescript
    const tx = await lucid
      .newTx()
      .pay.ToContract(
        "addr_test...",
        { kind: "inline", value: Data.to("31313131") },
        { lovelace: 5000000n }
      )
      .complete();

    const signedTx = await tx.sign.withWallet().complete();
    const txHash = await signedTx.submit();
    ```

  </Tabs.Tab>
</Tabs>

## Example

### Complete Payment Flow

Here's a complete example showing the entire payment flow:

```typescript
// Create a transaction
const tx = await lucid
  .newTx()
  .pay.ToAddress("addr_test...", { lovelace: 5000000n })
  .complete();

// Sign the transaction
const signedTx = await tx.sign.withWallet().complete();

// Submit the transaction
const txHash = await signedTx.submit();

// Wait for confirmation
await lucid.awaitTx(txHash);
console.log("Transaction confirmed!");
```

<Callout type="info">
**Minimum ADA Requirements**

Every UTxO on Cardano must hold a minimum amount of ADA (lovelace), which increases with UTxO size (in bytes). This is particularly relevant for native tokens, as their metadata adds to the UTxO size.

```typescript
const minLovelace = calculateMinLovelaceFromUTxO(
  coinsPerUtxoByte, // from protocol parameters
  utxo
);
```

The minimum ADA requirement acts as "rent" for blockchain storage, ensuring UTxOs cover their storage costs and preventing spam from tiny UTxOs (dust), which could bloat the blockchain state and degrade performance. It also guarantees sufficient ADA to cover future transaction fees for moving tokens.
</Callout>